"""
Vue d'administration pour la gestion des listes d√©roulantes
"""
import streamlit as st
import pandas as pd
from controllers.auth_controller import AuthController
from models.dropdown_options import DropdownOptionsModel

@AuthController.require_role(['admin'])
def admin_dropdown_options_page():
    """Page d'administration des listes d√©roulantes"""
    from views.components.header import display_header
    
    display_header()
    
    st.title("üéõÔ∏è Gestion des Listes D√©roulantes")
    st.markdown("Interface d'administration pour g√©rer toutes les options des listes d√©roulantes")
    
    # Onglets pour organiser les fonctionnalit√©s
    tab1, tab2, tab3, tab4 = st.tabs([
        "üìã Gestion des Options", 
        "‚ûï Ajouter Option", 
        "üìä Statistiques",
        "üîç Recherche"
    ])
    
    with tab1:
        _manage_options_tab()
    
    with tab2:
        _add_option_tab()
    
    with tab3:
        _statistics_tab()
    
    with tab4:
        _search_tab()

def _manage_options_tab():
    """Onglet de gestion des options"""
    st.subheader("üìã Gestion des Options Existantes")
    
    # S√©lecteur de cat√©gorie
    categories = {
        'budget': 'üí∏ Budget',
        'categorie': 'üìÇ Cat√©gorie', 
        'typologie_client': 'üè∑Ô∏è Typologie Client',
        'groupe_groupement': 'üë• Groupe/Groupement',
        'region': 'üåç R√©gion',
        'agence': 'üè¢ Agence'
    }
    
    selected_category = st.selectbox(
        "Choisir une cat√©gorie √† g√©rer",
        options=list(categories.keys()),
        format_func=lambda x: categories[x]
    )
    
    if selected_category:
        st.markdown(f"### {categories[selected_category]}")
        
        # R√©cup√©rer les options pour cette cat√©gorie
        options = DropdownOptionsModel.get_options_for_category(selected_category)
        
        if not options:
            st.info("Aucune option dans cette cat√©gorie")
            return
        
        # Afficher les options avec possibilit√© de modification
        for idx, option in enumerate(options):
            with st.expander(f"{option['label']} {'‚úÖ' if option.get('is_active', True) else '‚ùå'}", expanded=False):
                col1, col2, col3, col4 = st.columns([3, 1, 1, 2])
                
                with col1:
                    new_label = st.text_input(
                        "Libell√©", 
                        value=option['label'],
                        key=f"label_{option['id']}"
                    )
                
                with col2:
                    new_order = st.number_input(
                        "Ordre",
                        value=option['order_index'],
                        min_value=1,
                        key=f"order_{option['id']}"
                    )
                
                with col3:
                    is_active = st.checkbox(
                        "Actif",
                        value=option.get('is_active', True),
                        key=f"active_{option['id']}"
                    )
                
                with col4:
                    col_update, col_delete = st.columns(2)
                    
                    with col_update:
                        if st.button("üíæ Modifier", key=f"update_{option['id']}", use_container_width=True):
                            success, message = DropdownOptionsModel.update_option(
                                option['id'], 
                                label=new_label,
                                order_index=new_order,
                                is_active=is_active
                            )
                            
                            if success:
                                st.success(message)
                                st.rerun()
                            else:
                                st.error(message)
                    
                    with col_delete:
                        if st.button("üóëÔ∏è Supprimer", key=f"delete_{option['id']}", use_container_width=True):
                            if st.session_state.get(f"confirm_delete_{option['id']}", False):
                                success, message = DropdownOptionsModel.delete_option(option['id'])
                                
                                if success:
                                    st.success(message)
                                    st.rerun()
                                else:
                                    st.error(message)
                            else:
                                st.session_state[f"confirm_delete_{option['id']}"] = True
                                st.warning("Cliquez √† nouveau pour confirmer la suppression")

def _add_option_tab():
    """Onglet d'ajout d'option avec syst√®me centralis√©"""
    st.subheader("‚ûï Ajouter une Nouvelle Option")
    
    # Importer le syst√®me centralis√©
    from utils.dropdown_manager import DropdownCentralManager
    
    st.info("üéØ **Syst√®me Centralis√© Activ√©** - Les valeurs sont automatiquement normalis√©es")
    
    categories = {
        'budget': 'üí∏ Budget',
        'categorie': 'üìÇ Cat√©gorie', 
        'typologie_client': 'üè∑Ô∏è Typologie Client',
        'groupe_groupement': 'üë• Groupe/Groupement',
        'region': 'üåç R√©gion'
    }
    
    with st.form("add_option_form_centralized"):
        col1, col2 = st.columns(2)
        
        with col1:
            category = st.selectbox(
                "Cat√©gorie*",
                options=list(categories.keys()),
                format_func=lambda x: categories[x]
            )
            
            label = st.text_input(
                "Libell√© affich√©*",
                placeholder="Ex: NORD EST, Animation Client, SALES",
                help="Ce qui sera affich√© √† l'utilisateur"
            )
        
        with col2:
            # Afficher l'aper√ßu de normalisation EN TEMPS R√âEL
            if label:
                normalized_value = DropdownCentralManager.normalize_label_to_value(label)
                st.text_input(
                    "Valeur stock√©e (auto-g√©n√©r√©e)",
                    value=normalized_value,
                    disabled=True,
                    help="G√©n√©r√©e automatiquement : minuscule + espaces ‚Üí _"
                )
            else:
                st.text_input(
                    "Valeur stock√©e (auto-g√©n√©r√©e)",
                    value="",
                    disabled=True,
                    help="Saisissez d'abord un libell√©"
                )
            
            order_index = st.number_input(
                "Position dans la liste",
                min_value=1,
                value=1,
                help="Plus le num√©ro est petit, plus l'option appara√Æt en haut"
            )
        
        # Validation en temps r√©el
        errors = []
        if label and len(label.strip()) < 2:
            errors.append("Le libell√© doit contenir au moins 2 caract√®res")
        
        if label:
            normalized_value = DropdownCentralManager.normalize_label_to_value(label)
            if not normalized_value:
                errors.append("Impossible de g√©n√©rer une valeur valide √† partir du libell√©")
        
        if errors:
            for error in errors:
                st.error(f"‚ö†Ô∏è {error}")
        
        # Aper√ßu de la transformation
        if label and not errors:
            st.markdown("### üîé Aper√ßu de la Transformation")
            normalized_value = DropdownCentralManager.normalize_label_to_value(label)
            
            col_before, col_arrow, col_after = st.columns([2, 1, 2])
            with col_before:
                st.code(f"Libell√©: '{label}'")
            with col_arrow:
                st.markdown("<div style='text-align: center; font-size: 24px;'>‚Üí</div>", unsafe_allow_html=True)
            with col_after:
                st.code(f"Valeur: '{normalized_value}'")
        
        # Actions
        col1, col2 = st.columns(2)
        
        with col1:
            submit_btn = st.form_submit_button(
                "‚úÖ Ajouter l'Option",
                use_container_width=True,
                type="primary"
            )
        
        with col2:
            if st.form_submit_button("üîÑ R√©initialiser", use_container_width=True):
                st.rerun()
    
    # Traitement du formulaire
    if submit_btn:
        if not all([category, label]):
            st.error("‚ö†Ô∏è Veuillez remplir tous les champs obligatoires")
            return
        
        if errors:
            st.error("‚ö†Ô∏è Veuillez corriger les erreurs avant de continuer")
            return
        
        # Utiliser le syst√®me centralis√© pour cr√©er l'option
        success, message = DropdownCentralManager.create_option_from_admin(
            category, label.strip(), order_index
        )
        
        if success:
            st.success(f"‚úÖ Option cr√©√©e avec succ√®s!")
            st.balloons()
            
            # Afficher un aper√ßu d√©taill√©
            normalized_value = DropdownCentralManager.normalize_label_to_value(label)
            
            st.markdown("### üëÅÔ∏è R√©sum√© de l'Option Cr√©√©e")
            
            col1, col2 = st.columns(2)
            with col1:
                st.info(f"**Cat√©gorie:** {categories[category]}")
                st.info(f"**Libell√© affich√©:** {label}")
            with col2:
                st.info(f"**Valeur stock√©e:** {normalized_value}")
                st.info(f"**Position:** {order_index}")
                
            st.success("üîí Cette option est maintenant la SEULE fa√ßon d'utiliser cette valeur dans le syst√®me")
        else:
            st.error(f"‚ùå {message}")

def _statistics_tab():
    """Onglet des statistiques"""
    st.subheader("üìä Statistiques des Listes D√©roulantes")
    
    # Statistiques par cat√©gorie
    stats = DropdownOptionsModel.get_category_stats()
    
    if stats:
        df_stats = pd.DataFrame(stats)
        
        # Renommer les colonnes pour l'affichage
        df_stats['Cat√©gorie'] = df_stats['category'].map({
            'budget': 'üí∏ Budget',
            'categorie': 'üìÇ Cat√©gorie', 
            'typologie_client': 'üè∑Ô∏è Typologie Client',
            'groupe_groupement': 'üë• Groupe/Groupement',
            'region': 'üåç R√©gion',
            'agence': 'üè¢ Agence'
        })
        
        # M√©triques globales
        col1, col2, col3, col4 = st.columns(4)
        
        with col1:
            total_options = df_stats['total'].sum()
            st.metric("Total Options", total_options)
        
        with col2:
            total_active = df_stats['active'].sum()
            st.metric("Options Actives", total_active)
        
        with col3:
            total_inactive = df_stats['inactive'].sum()
            st.metric("Options Inactives", total_inactive)
        
        with col4:
            nb_categories = len(df_stats)
            st.metric("Cat√©gories", nb_categories)
        
        # Tableau d√©taill√©
        st.markdown("### üìà D√©tail par Cat√©gorie")
        
        # Pr√©parer le dataframe pour l'affichage
        display_df = df_stats[['Cat√©gorie', 'total', 'active', 'inactive']].copy()
        display_df.columns = ['Cat√©gorie', 'Total', 'Actives', 'Inactives']
        
        st.dataframe(
            display_df,
            use_container_width=True,
            hide_index=True
        )
        
        # Graphique
        import plotly.express as px
        
        fig = px.bar(
            df_stats, 
            x='Cat√©gorie', 
            y=['active', 'inactive'],
            title="R√©partition des Options par Cat√©gorie",
            color_discrete_map={'active': '#28a745', 'inactive': '#dc3545'}
        )
        
        st.plotly_chart(fig, use_container_width=True)
    
    else:
        st.info("Aucune donn√©e statistique disponible")

def _search_tab():
    """Onglet de recherche"""
    st.subheader("üîç Recherche dans les Options")
    
    col1, col2 = st.columns([2, 1])
    
    with col1:
        search_term = st.text_input(
            "Terme de recherche",
            placeholder="Rechercher dans les libell√©s ou valeurs..."
        )
    
    with col2:
        category_filter = st.selectbox(
            "Filtrer par cat√©gorie",
            options=[''] + list({
                'budget': 'üí∏ Budget',
                'categorie': 'üìÇ Cat√©gorie', 
                'typologie_client': 'üè∑Ô∏è Typologie Client',
                'groupe_groupement': 'üë• Groupe/Groupement',
                'region': 'üåç R√©gion',
                'agence': 'üè¢ Agence'
            }.keys()),
            format_func=lambda x: "Toutes les cat√©gories" if x == '' else {
                'budget': 'üí∏ Budget',
                'categorie': 'üìÇ Cat√©gorie', 
                'typologie_client': 'üè∑Ô∏è Typologie Client',
                'groupe_groupement': 'üë• Groupe/Groupement',
                'region': 'üåç R√©gion',
                'agence': 'üè¢ Agence'
            }[x]
        )
    
    if search_term:
        # Effectuer la recherche
        results = DropdownOptionsModel.search_options(
            search_term, 
            category_filter if category_filter else None
        )
        
        if not results.empty:
            st.markdown(f"### üìã R√©sultats ({len(results)} trouv√©s)")
            
            # Afficher les r√©sultats
            for _, row in results.iterrows():
                status_icon = "‚úÖ" if row['is_active'] else "‚ùå"
                category_icon = {
                    'budget': 'üí∏',
                    'categorie': 'üìÇ', 
                    'typologie_client': 'üè∑Ô∏è',
                    'groupe_groupement': 'üë•',
                    'region': 'üåç',
                    'agence': 'üè¢'
                }.get(row['category'], 'üìÅ')
                
                with st.expander(f"{status_icon} {category_icon} {row['label']} ({row['category']})"):
                    col1, col2, col3 = st.columns(3)
                    
                    with col1:
                        st.markdown(f"**Libell√©:** {row['label']}")
                        st.markdown(f"**Valeur:** `{row['value']}`")
                    
                    with col2:
                        st.markdown(f"**Cat√©gorie:** {row['category']}")
                        st.markdown(f"**Position:** {row['order_index']}")
                    
                    with col3:
                        st.markdown(f"**Statut:** {'Actif' if row['is_active'] else 'Inactif'}")
                        
                        # Boutons d'action rapide
                        if st.button(f"‚úèÔ∏è Modifier", key=f"edit_search_{row['id']}"):
                            st.session_state.edit_option_id = row['id']
                            st.session_state.page = "admin_dropdown_options"
                            st.rerun()
        else:
            st.info("Aucun r√©sultat trouv√© pour cette recherche")
    
    else:
        st.info("üí° Saisissez un terme de recherche pour commencer")
        
        # Afficher quelques exemples
        st.markdown("### üí° Exemples de recherche")
        st.markdown("- `Marketing` - Trouve toutes les options contenant 'Marketing'")
        st.markdown("- `Paris` - Trouve les agences ou r√©gions contenant 'Paris'")
        st.markdown("- `Budget` - Trouve toutes les options li√©es au budget")

def _export_import_section():
    """Section d'export/import (bonus)"""
    st.markdown("---")
    st.subheader("üì§üì• Export / Import")
    
    col1, col2 = st.columns(2)
    
    with col1:
        st.markdown("#### üì§ Exporter les Options")
        if st.button("üíæ Exporter vers Excel", use_container_width=True):
            # R√©cup√©rer toutes les options
            df = DropdownOptionsModel.get_all_options()
            
            if not df.empty:
                # Cr√©er le fichier Excel
                from io import BytesIO
                buffer = BytesIO()
                
                with pd.ExcelWriter(buffer, engine='openpyxl') as writer:
                    df.to_excel(writer, sheet_name='Options', index=False)
                
                buffer.seek(0)
                
                st.download_button(
                    label="üì• T√©l√©charger le fichier Excel",
                    data=buffer.getvalue(),
                    file_name=f"dropdown_options_{pd.Timestamp.now().strftime('%Y%m%d_%H%M')}.xlsx",
                    mime="application/vnd.openxmlformats-officedocument.spreadsheetml.sheet"
                )
            else:
                st.warning("Aucune donn√©e √† exporter")
    
    with col2:
        st.markdown("#### üì• Importer des Options")
        st.info("Fonctionnalit√© disponible prochainement")
